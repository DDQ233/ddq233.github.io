<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.68.3" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>Maven习笔记&nbsp;&ndash;&nbsp;DDQ的笔记</title><link rel="stylesheet" href="/css/core.min.9d9a71a2aa7bfa7cd0fa3d29cca2abd80ea10e5d886dd01abe9e6b2c1a16fb345670afedd884e7805ad44ccb9c2cc877.css" integrity="sha384-nZpxoqp7&#43;nzQ&#43;j0pzKKr2A6hDl2IbdAavp5rLBoW&#43;zRWcK/t2ITngFrUTMucLMh3"><body>
    <div class="base-body"><section id="header" class="site header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><img class="site logo" src="/Logo.jpg" alt /><span class="site name">DDQ的笔记</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/categories/">Categories</a><a class="nav item" href="/tags/">Tags</a><a class="nav item" href="/about">About</a></nav></div></span></div><div class="site slogan"><span class="title">DDQ Note Library</span></div></section><div id="content"><div class="article-container"><section class="article header">
    <h1 class="article title">Maven习笔记</h1><p class="article date">Date : 2020-04-26</p></section><article class="article markdown-body"><h1 id="目录">目录</h1>
<ul>
<li>
<ol>
<li>为什么要使用 Maven ？</li>
</ol>
</li>
<li>
<ol start="2">
<li>什么是 Maven ？</li>
</ol>
<ul>
<li>2.1 构建</li>
<li>2.3 构建的主要环节</li>
</ul>
</li>
<li>
<ol start="3">
<li>Maven 的核心概念</li>
</ol>
<ul>
<li>3.1 约定的目录结构</li>
<li>3.2 POM</li>
<li>3.3 坐标</li>
<li>3.4 依赖
<ul>
<li>3.4.1 依赖的范围</li>
</ul>
</li>
<li>3.5 仓库
<ul>
<li>3.5.1 分类</li>
<li>3.5.2 仓库的文件</li>
</ul>
</li>
<li>3.6 生命周期
<ul>
<li>3.6.1 Maven 的生命周期</li>
</ul>
</li>
<li>3.7 插件和目标</li>
<li>3.8 继承</li>
<li>3.9 聚合</li>
</ul>
</li>
</ul>
<hr>
<p><strong>前言：</strong> 生产环境下开发不再是一个项目一个工程，而是每一个模块创建一个工程，而多个模块整合在一起就需要使用到像 Maven 这样的构建工具</p>
<h1 id="1-为什么要使用-maven-">1. 为什么要使用 Maven ？</h1>
<p>为什么要使用 Maven ？它能帮助我们解决什么问题？</p>
<p><strong>(1) 轻松添加第三方 jar 包</strong></p>
<p>        在开发过程中，同样的 jar 包会出现在不同的工程项目中，开发人员需要不停地做 jar 包的复制粘贴工作。这些操作会导致工作区中存在大量重复的文件，让工程显得很臃肿。</p>
<p>        使用 Maven 后，只需要把 jar 包保存在【仓库】中，需要用到 jar 包的工程只需要以坐标的方式简单引用一下即可。</p>
<p>        使用 Maven 的好处就是极大的节约了存储空间，让项目更轻巧，避免了重复文件太多而造成的混乱。</p>
<p><strong>(2) 解决 jar 包之间的依赖关系的问题</strong></p>
<p>        jar 包往往不是孤立存在的，有时候一个 jar 包的正常工作需要依赖另一个或多个 jar 包。而作为开发人员，不可能知道所有 jar 包之间的依赖关系并正确导入工程项目中，极大地浪费了我们导入包的时间成本，也极大地增加了学习成本。</p>
<p>        引入 Maven 后，Maven 就可以替我们自动的将当前 jar 包所依赖的其他所有 jar 包全部导入进来，无需人工参与，节约了我们大量的时间和精力。</p>
<p><strong>(3) 获取第三方 jar 包</strong></p>
<p>        在开发过程中使用到的 jar 包种类繁多，不可能把精力都花在到互联网寻找 jar 包上面，费时费力。</p>
<p>        因此，借助 Maven 可以帮助我们解决问题。我们只需要在项目中以坐标的方式依赖一个 jar 包，Maven 就会自动从中央仓库进行下载 jar 包和这个 jar 包所依赖的其他 jar 包。</p>
<p><strong>(4) jar 包版本不一致导致的风险</strong></p>
<p>        不同的项目在使用 jar 包的时候，有可能会导致各个项目的 jar 包版本不一致，导致未知性的错误。</p>
<p>        借助 Maven ，所有的 jar 包都放在【仓库】中，所有的项目都使用仓库的一份 jar 包</p>
<p><strong>(5) 将项目拆分成多个工程模块</strong></p>
<p>        如果在大的项目中，就不适合用 package 来划分模块，必须将项目拆分成多个工程协同开发。借助 Maven 就可以将一个项目拆分成多个工程。</p>
<br>
<hr>
<h1 id="2-什么是-maven-">2. 什么是 Maven ？</h1>
<p>        Maven 是 Apache 软件基金会组织维护的一款自动化构建工具，专注服务于 Java 平台的项目构建和依赖管理。</p>
<p>        构建工具的发展历程：make &ndash;&gt; Ant &ndash;&gt; Maven &ndash;&gt; Gradle</p>
<h2 id="21-构建">2.1 构建</h2>
<p>        构建就是以我们编写的Java代码、框架配置文件、国际化等其他资源文件、JSP页面和图片等静态资源作为【原材料】，去【生产】出一个可以运行的项目的过程。</p>
<p>        简而言之就是，把 动态Web工程 经过编译得到的结果部署到服务器上的过程。</p>
<h2 id="23-构建的主要环节">2.3 构建的主要环节</h2>
<p><strong>(1) 清理 (Clean) ：</strong> 删除以前的编译结果，为重新编译做好准备</p>
<p><strong>(2) 编译 (Complie) ：</strong> 将 Java 源程序编译为字节码文件</p>
<p><strong>(3) 测试 (Test) ：</strong> 针对项目中的关键点进行测试，确保项目在迭代开发过程中关键点的正确性</p>
<p><strong>(4) 报告 (Report) ：</strong> 在每一次测试以后以标准的格式记录和展示测试结果</p>
<p><strong>(5) 打包 (Package) ：</strong> 将一个包含诸多文件的工程封装为一个压缩文件用于安装或部署。Java工程 对应 jar 包， Web工程 对应 war 包</p>
<p><strong>(6) 安装 (Install) ：</strong> Maven 特定的概念，将打包后得到的文件，jar 包或者 war 包安装到本地仓库中</p>
<p><strong>(7) 部署 (Deploy) ：</strong> 将打包的结果部署到远程仓库或者将 war 包部署到服务器上运行</p>
<br>
<hr>
<h1 id="3-maven-的核心概念">3. Maven 的核心概念</h1>
<p>(1) 约定的目录结构
(2) POM
(3) 坐标
(4) 依赖管理
(5) 仓库管理
(6) 生命周期
(7) 插件和目标
(8) 继承
(9) 聚合</p>
<h2 id="31-约定的目录结构">3.1 约定的目录结构</h2>
<p>        Maven 的正常工作要求工程按照约定了目录结构创建。</p>
<p>目录结构：</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">根目录：工程名
|--- src  源码目录
|---|--- main  主程序目录
|---|---|--- java  java源文件目录
|---|---|--- resource  资源文件目录
|---|--- test  测试程序目录
|--- target  编译结果目录
|--- pom.xml  Maven核心配置文件
</code></pre></div><p>        一般来说，能用配置解决的问题就不编码，能基于约定就不进行配置（约定 &gt; 配置 &gt; 编码）。</p>
<h2 id="32-pom">3.2 POM</h2>
<p>        POM（Project Object Model）：项目对象模型。将 Java <strong>工程</strong>的相关信息封装为<strong>对象</strong>作为便于操作和管理的<strong>模型</strong>。
Maven 工程的核心配置。</p>
<h2 id="33-坐标">3.3 坐标</h2>
<p>        在 Maven 中，<code>groupId</code> 、 <code>artifactId</code> 、 <code>version</code> 三个向量能唯一确定一个 Maven 工程。</p>
<ul>
<li><strong>groupId：</strong> 公司或组织的域名倒序 + 当前项目名称</li>
<li><strong>artifactId：</strong> 当前项目的模块名称</li>
<li><strong>version：</strong> 当前模块的版本</li>
</ul>
<p><strong>注意：</strong> 自己的 Maven 工程必须执行安装操作才会进入仓库。安装的命令是：<code>mvn install</code></p>
<h2 id="34-依赖">3.4 依赖</h2>
<p>        依赖是 Maven 中最关键的部分，我们使用 Maven 最主要的就是使用它的依赖管理功能。</p>
<p>        当工程需要第三方 jar 包或者其他工程模块时，就需要用到 Maven 到依赖功能。</p>
<p>        Maven 的依赖使用非常简单，只需要在 <code>pom.xml</code> 文件中使用 <code>dependency</code> 标签指定指定依赖的 jar 包的坐标就可以了。</p>
<p>例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;dependencies&gt;</span>
    <span class="nt">&lt;dependency&gt;</span>
        <span class="nt">&lt;groupId&gt;</span>junit<span class="nt">&lt;/groupId&gt;</span>
        <span class="nt">&lt;artifactId&gt;</span>junit<span class="nt">&lt;/artifactId&gt;</span>
        <span class="nt">&lt;version&gt;</span>4.0<span class="nt">&lt;/version&gt;</span>
        <span class="nt">&lt;scope&gt;</span>test<span class="nt">&lt;/scope&gt;</span>
    <span class="nt">&lt;/dependency&gt;</span>
<span class="nt">&lt;/dependencies&gt;</span>
</code></pre></div><h2 id="341-依赖的范围">3.4.1 依赖的范围</h2>
<p>        在依赖信息设置中有一个 <code>scope</code> 标签，这就是设置依赖的范围。依赖的范围有几个可选值，<code>complie</code> 、 <code>provided</code> 、 <code>runtime</code> 、 <code>test</code> 、 <code>system</code>。</p>
<p>三个属性的有效性：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">complie</th>
<th align="center">test</th>
<th align="center">provided</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">主程序</td>
<td align="center">√</td>
<td align="center">X</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">测试程序</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">参与部署</td>
<td align="center">√</td>
<td align="center">X</td>
<td align="center">X</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>complie：</strong> 默认值，适用于所有阶段（开发、测试、部署、运行），本jar会一直存在所有阶段。</li>
<li><strong>provided：</strong> 只在开发、测试阶段使用，目的是不让Servlet容器和你本地仓库的jar包冲突 。如servlet.jar。</li>
<li><strong>runtime：</strong> 只在运行时使用，如JDBC驱动，适用运行和测试阶段。</li>
<li><strong>test：</strong> 只在测试时使用，用于编译和运行测试代码。不会随项目发布。</li>
<li><strong>system：</strong> 类似provided，需要显式提供包含依赖的jar，Maven不会在Repository中查找它。</li>
</ul>
<h2 id="35-仓库">3.5 仓库</h2>
<h3 id="351-分类">3.5.1 分类</h3>
<ul>
<li><strong>本地仓库：</strong> 为当前本机电脑上的所有 Maven 工程服务</li>
<li><strong>远程仓库</strong>
<ul>
<li><strong>私服：</strong> 架设在当前局域网环境下，为当前局域网范围内的所有 Maven 工程服务。</li>
<li><strong>中央仓库：</strong> 架设在 Internet 上，为全世界所有 Maven 工程服务。</li>
<li><strong>中央仓库的镜像：</strong> 架设在各个大洲，为中央仓库分担流量。减轻中央仓库的压力，同时更快地响应用户请求。</li>
</ul>
</li>
</ul>
<h3 id="352-仓库的文件">3.5.2 仓库的文件</h3>
<ul>
<li>Maven 的插件</li>
<li>我们自己开发的项目模块</li>
<li>第三方框架或工具的 jar 包</li>
</ul>
<p>        不管是什么样的 jar 包，在仓库中都是按照坐标生成目录结构，所以可以通过统一的方式查询或依赖。</p>
<h2 id="36-生命周期">3.6 生命周期</h2>
<h3 id="361-maven-的生命周期">3.6.1 Maven 的生命周期</h3>
<p>        Maven 生命周期定义了各个构建环节的执行顺序，有了这个清单，Maven 就可以自动化的执行构建命令了。</p>
<p>        Maven 有三套独立的生命周期，分别是：<code>Clean Lifecycle</code> 、 <code>Default Lifecycle</code> 、 <code>Site Lifecycle</code>。</p>
<p><strong>(1) Clean Lifecycle：</strong> 在进行真正的构建之前进行一些清理工作。</p>
<p><strong>(2) Default Lifecycle：</strong> 构建的核心部分，编译，测试，打包，安装，部署等等。</p>
<p><strong>(3) Site Lifecycle：</strong> 生成项目报告，站点，发布站点。</p>
<h3 id="362-clean-生命周期">3.6.2 Clean 生命周期</h3>
<p><strong>(1) pre-clean：</strong> 执行一些需要在clean之前完成的工作</p>
<p><strong>(2) clean：</strong> 移除所有上一次构建生成的文件</p>
<p><strong>(3) post-clean：</strong> 执行一些需要在clean之后立刻完成的工作</p>
<h3 id="363-site-生命周期">3.6.3 Site 生命周期</h3>
<p><strong>(1) pre-site：</strong> 执行一些需要在生成站点文档之前完成的工作</p>
<p><strong>(2) site：</strong> 生成项目的站点文档</p>
<p><strong>(3) post-site：</strong> 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备</p>
<p><strong>(4) site-deploy：</strong> 将生成的站点文档部署到特定的服务器上</p>
<h3 id="364-default-生命周期">3.6.4 Default 生命周期</h3>
<ul>
<li>validate</li>
<li>generate-sources</li>
<li>process-sources</li>
<li>generate-resources</li>
<li>process-resources 复制并处理资源文件，至目标目录，准备打包。</li>
<li>compile 编译项目的源代码。</li>
<li>process-classes</li>
<li>generate-test-sources</li>
<li>process-test-sources</li>
<li>generate-test-resources</li>
<li>process-test-resources 复制并处理资源文件，至目标测试目录。</li>
<li>test-compile 编译测试源代码。</li>
<li>process-test-classes</li>
<li>test 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。</li>
<li>prepare-package</li>
<li>package 接受编译好的代码，打包成可发布的格式，如 JAR。</li>
<li>pre-integration-test</li>
<li>integration-test</li>
<li>post-integration-test</li>
<li>verify</li>
<li>install 将包安装至本地仓库，以让其它项目依赖。</li>
<li>deploy 将最终的包复制到远程的仓库，以让其它开发人员与项目共享或部署到服务器上运行。</li>
</ul>
<h2 id="37-插件和目标">3.7 插件和目标</h2>
<p>        Maven 的核心仅仅定义了抽象的生命周期，具体的任务都是交由插件完成的。</p>
<p>        每个插件都能实现多个功能，每个功能就是一个插件目标。</p>
<p>        Maven 的生命周期与插件目标相互绑定，以完成某个具体的构建任务。</p>
<h2 id="38-继承">3.8 继承</h2>
<p>        由于非 compile 范围的依赖信息是不能在“依赖链”中传递的，所以有需要的工程只能单独配置。使用继承机制就可以将这样的依赖信息统一提取到父工程模块中进行统一管理。</p>
<h2 id="39-聚合">3.9 聚合</h2>
<p>        将多个工程拆分为模块后，需要手动逐个安装到仓库后依赖才能够生效。修改源码后也需要逐个手动进行 clean 操作。而使用了聚合之后就可以批量进行 Maven 工程的安装、清理工作。</p>
</article><section class="article labels"><a class="category" href=/categories/buildtools/>BuildTools</a><a class="tag" href=/tags/maven/>Maven</a></section></div><section class="article navigation"><p><a class="link" href="/notes/spring_datasource_configure/"><span class="li">&rarr;</span>8种常用的数据库数据源配置和相应的JDBC驱动包</a></p></section></div><section id="footer" class="footer"><div class="footer-wrap">
    <p class="copyright">© 2020 DDQ.</p>
    <p class="powerby"><span>Powered by </span><a href="https://gohugo.io" 
        target="_blank">Hugo</a><span> and the </span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank">Notepadium</a></p>
</div></section><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/&#43;DiW/UqRcLbRjq" crossorigin="anonymous"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l&#43;B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd&#43;qj&#43;o24G5ZU2zJz" crossorigin="anonymous"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
            onload="renderMathInElement(document.body);"></script><script src="/js/hljs.min.0799348a91dce12c6be4a73f943cfe78f181f4e6f6ec35c4af0fca1de377879f77cfab03c30f03a174d675737b5a9314.js" integrity="sha384-B5k0ipHc4Sxr5Kc/lDz&#43;ePGB9Ob27DXErw/KHeN3h593z6sDww8DoXTWdXN7WpMU"></script><script>hljs.initHighlightingOnLoad();</script></div>
</body>

</html>